# 补充知识

### 闭包

代码如下：

```
var x = 10

function fn() {
    console.log(x) 
    x -= 4
}
```

我们在同一作用域（全局作用域window）声明了变量x及函数fn，在函数中可以访问到函数外的x,不知不觉中便形成了一个最简单的闭包.

思考一个问题： 出于种种原因，我们有时候需要得到函数内的局部变量。那么如何从外部读取局部变量？



那么，上面的例子修改成：

```
function foo(){
	var x = 10

    function fn() {
        console.log(x) 
        x -= 4
    }
    return fn
}

var fn=foo(); // 得到 foo() 执行后返回的 fn 函数
fn() // 之后无论何时调用 fn，都还能访问到变量x
```

改后，x是一个局部变量，在foo()函数外部无法直接访问。只能通过fn()函数访问，我们把fn()函数作为foo()的返回值返回，以备后续调用。之后无论何时再执行fn()，都能访问到x，因此，虽然foo()函数执行完了，但x变量没有被释放.

由此可见，当函数跨作用域（子访问父）访问变量时，便会形成闭包，而这种“父函数嵌套子函数，子函数访问父函数中变量，再将子函数返回或者挂载到全局”的写法，也是常见的形成闭包的方式。



闭包的定义非常抽象，很难看懂。我的理解是：闭包就是能够读取其他函数内部变量的函数。由于在js语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。



例如：写一个for循环，让它按顺序打印出当前循环次数

```
for (var i = 0; i < 5; i++) {
    setTimeout(() => {
    	console.log(i) // 1s 后，打印 0 1 2 3 4
    }, 1000)
}
// 由于js是单线程的，所以在执行for循环的时候定时器setTimeout被安排到任务队列中排队等待执行，而在等待过程中for循环就已经在执行，等到setTimeout可以执行的时候，for循环已经结束，i的值也已经编程5，所以打印出来五个5
```

```
for (var i = 0; i < 5; i++) {
    (function(i) {
        setTimeout(() => {
        	console.log(i) // 1s 后，打印 0 1 2 3 4
        }, 1000)
    })(i);
}
// 引入闭包来保存变量i，将setTimeout放入立即执行函数中，将for循环中的循环值i作为参数传递，1秒后同时打印出1 2 3 4 5
```



总结一下闭包的优点和缺点

优点:

- 可以读取函数内部的变量
- 变量的值始终保持在内存中

缺点：

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会可能导致内存泄露，造成网页的性能问题。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
- 闭包会在父函数外部，改变父函数内部变量的值。所以一定要小心，不要随便改变父函数内部变量的值。















### 正则表达式

###### 概念

- 正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，用于判断字符串数据是否满足该规则的字符串搜索模式。本质上，正则表达式是一个特殊的"字符串",用于表示规则。而这个规则用于判断其他的字符串数据是否满足该规则。比如说字符串需满足手机号，邮箱、QQ号。

- 如何运用正则表达式来验证数据是否满足我们的要求。正是学习正则表达式的核心
  - 正则表达式语法
  - 使用步骤

###### 基础语法

- 定义一个正则表达式

  ```
  第一种：正则表达式字面量形式。第二种的快捷方式，常用
  let 正则表达式变量名 = /正则表达式/;
  第二种：直接定义一个正则表达式的对象
  let 正则表达式变量名 = new RegExp("正则表达式");
  ```

- 正则表达式语法

  - `[]`:匹配[]里的任意一个字符
    - `[12345]`:匹配12345中的其中一个
    - `[0-9]`:匹配0123456789中的一个，相当于`[0123456789]`,相当于简写
    - `[abcde]`:匹配abcde中的其中一个。
    - `[a-zA-Z]`:匹配任何一个字母
    - `[a-z0-9A-Z]`:匹配任意一个数字或字母
    - `[0-9][0-9]`:匹配两个连续数字
  - `{n,m}`:匹配前面的正则表达式的出现的次数.n表示至少的次数，而m表示最多的次数.n和m可以省略
    - `[0-9]{0,3}`:表示可以最多出现连续的3个数字，也可以没有数字。
    - `[a-z]{1,4}`:表示出现至少一个小写字母，最多连续4个小写字母。
    - `[0-9]{1,}`:至少出现一个数字，也可以连续多个数字
    - `[0-9]{3}`：刚好连续三个数字
    - `[0-9]{,3}`:最多3个连续的数字
    - 注意
      - 默认情况下，只会匹配的是字符串中的一部分，只要其中满足了条件，后续的字符就不会处理。
  - 对整个字符串进行判断
    - `^`:在开头则表示字符串以什么开始，在[]里表示取反。
      - `^[0-9]`:字符串以数字开头
      - `[^0-9]`:表示非数字以外的任何一个字符
    - `$`:在正则表达式结尾表示以什么字符结尾
  - 固定字符串的判断
    - `(字符串1|字符串2|字符串N)`：匹配n个字符串中的任意一个
      - `(java|Type)Script`:匹配JavaScript或TypeScript
  - 常用的快捷语法
    - `+`:相当于`{1,}`。至少一次
    - `*`:相当于`{0,}`:可有可无，也可以多次，即任意数量。
    - `?`:相当于`{0,1}`:那么有，那么有一次。
    - `\w`:匹配一个单词字符。相当于`[0-9a-zA-Z_]`一次。
    - `\d`:匹配一个数字.相当于`[0-9]`
    - `\S`:匹配一个非空白字符.相当于`[^ ]`

例如：

```
1. 匹配整个字符串是否都是单词字符
let reg = /^\w*$/
2. 匹配整个字符串是否为3-5个单词字符
let reg = /^\w{3,5}$/;

3. 一个数字开头，后面紧跟10个字母
let reg = /^[0-9][a-zA-Z]{10}$/;
4. 手机号：第一位必须是1，第二位必须是3456789，第三位及以后都是数字，长度为11
 let reg = /^1[3-9]\d{9}$/;
 
 5. 以大写字母开头，后面的数字可有可无，最后至少有一个字母
 let reg = /^[A-Z][0-9]*[a-zA-Z]+$/;
 6. 匹配整个字符串是否是10个数字
 let reg = /^[0-9]{10}$/
```





- **正则表达式的一般使用步骤**
  - 分析条件，定义正则表达式
  - 调用正则表达式提供的方法来进行检测





###### RegExp对象方法

###### test

 - 用于检测某个字符串是否满足了正则表达式,返回true或者false，true表示满足正则表达式。false则是不满足

   ```javascript
   var regexp = /[12345]/; 匹配数据中是否包含了12345中的其中一个
   var str = "h4llo";
   regexp.test(str); //true  
   ```

###### exec

 - 对数据进行判断，是否满足正则表达式，作用类似于test，但返回的是一个数组，包含了匹配上的字符串以及对应的下标。

   ```javascript
   var regexp = /[12345]/; 匹配数据中是否包含了12345中的其中一个
   var str = "h4llo";
   regexp.exec(str); //返回匹配项的位置，以及满足条件的字符串部分。
   
   ```

- 注意

  - 如果返回的是null，说明没有匹配上，即不满足正则表达式

###### 正则表达式-模式

- 概念：不同的模式决定了正则表达式如去匹配字符串。比如匹配一次或者匹配所有的。是否考虑大小写

- 常见模式

  - `u`:只匹配最近的那个 (默认模式)
  - `g`:全局匹配.匹配所有的满足条件的字符串。
  - `i`：忽略大小写

- 使用

  ```javascript
  var reg = /[0-9]+/g;// 使用的是全局匹配
  var reg = new RegExp("[0-9]+","g");
  ```

  

###### 正则表达式在字符串中的应用：match 

 - 概念：字符串所使用的方法。用于判断某个字符串是否满足了指定的正则表达式。作用类似于正则表达式提供的exec.

 - 特点

   - 如果不是全局匹配，那么返回的是最近匹配的第一个
     - 如果是全局匹配，那么会返回所有匹配的结果

- 使用

  ```javascript
  字符串.match(正则表达式);
  例子：
   var str = "hello woniuxy webfrontend";
   var reg =/ \w+/g;
   var result = str.match(reg);  [' woniuxy',' webfrontend'];
  ```





### 扩展

###### split

 - 概念：按照指定的分割符将字符串分割成数组，分隔符支持正则表达式。

 - 使用

   ```javascript
   字符串.split(正则表达式);
   
   var str = "张三@赵四@@王五###赵六123田七aaa阿八GGG三九fjd89阿十";
   var reg = /[@#0-9a-zA-Z]+/;//匹配分隔符
   console.log(str.split(reg));//Array(8) [ "张三", "赵四", "王五", "赵六", "田七", "阿八", "三九", "阿十" ]
   ```

###### replace

 - 概念： 替换字符串中的字符，旧字符支持正则表达式。

   ```javascript
   字符串.replace(查询旧字符串的正则表达式,替换字符串);
   
   //吧分隔符替换成空格
   var str = "张三@赵四@@王五###赵六123田七aaa阿八GGG三九fjd89阿十";
   var reg = /[@#0-9a-zA-Z]+/g;//匹配分隔符
   console.log(str.replaceAll(reg," "));
   ```

   - 替换所有的,无论是`replace`还是`replaceAll`,正则表达式都要加上全局匹配`g`。

